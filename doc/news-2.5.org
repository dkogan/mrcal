#+TITLE: mrcal 2.5 release notes
#+OPTIONS: toc:nil

* New in mrcal 2.5
This is yet another mostly-maintenance release. The bulk implementation of some
new big features is committed, but not yet completed and tested. These are thus
undocumented, until they're done and finally appear in mrcal 3.0:

- Cross-reprojection uncertainty, to be able to perform full calibrations with a
  splined model and /without/ a chessboard
- Implicit point solves, using the triangulation routines in the optimization
  cost function. Should produce more efficient SFM

** General fixes

- poseutils: more careful handling of rotations near singularities. Rotations
  by ~ 180deg in particular weren't implemented properly, and had bugs

- Renamed "residuals" -> "measurements" to clarify the nomenclature. These are
  similar except for scaling and the "measurements" may also contain
  regularization.
  - =residuals_point()= -> =measurements_point()=
  - =residuals_board()= -> =measurements_board()=
  - =show_residuals_....()= functions now ask for a measurement =x= argument;
    the old =residuals= argument is still accepted for backwards compatibility

- Added =mrcal_traverse_sensor_links()= in C and =mrcal.traverse_sensor_links()=
  in Python. These compute the best path through a graph of sensors, trying to
  maximize the common observations between each successive pair of sensors in
  the path. The general min-heap implementation at the core of this computation
  is available in =heap.h=

- mrcal-calibrate-cameras has a higher minimum points-per-chessboard-observation
  threshold. We now throw out any images where a chessboard detection has fewer
  than =2*min(gridn_width,gridn_height)= points. This is irrelevant for
  mrgingham, which produces all-or-nothing detections. But other detectors could
  produce barely-adequate detections that could cause problems previously

** C API 
Some guts of the calibration machinery have been ported to C and exposed as C
functions:

- Added C implementations of Procrustes fits:
  =mrcal_align_procrustes_vectors_R01()= and
  =mrcal_align_procrustes_points_Rt01()=. These are now the internal
  implementations of the Python [[file:mrcal-python-api-reference.html#-align_procrustes_vectors_R01][=mrcal.align_procrustes_vectors_R01()=]] and
  [[file:mrcal-python-api-reference.html#-align_procrustes_points_Rt01][=mrcal.align_procrustes_points_Rt01()=]] functions

- Added =mrcal_R_aligned_to_vector()= C function. This is now the internal
  implementation of [[file:mrcal-python-api-reference.html#-R_aligned_to_vector][=mrcal.R_aligned_to_vector()=]]

- Added simple math operation functions to the C API:
  - =double         mrcal_point3_inner(const mrcal_point3_t a, const mrcal_point3_t b)=
  - =double         mrcal_point3_norm2(const mrcal_point3_t a)=
  - =double         mrcal_point3_mag  (const mrcal_point3_t a)=
  - =mrcal_point3_t mrcal_point3_add  (const mrcal_point3_t a, const mrcal_point3_t b)=
  - =mrcal_point3_t mrcal_point3_sub  (const mrcal_point3_t a, const mrcal_point3_t b)=
  - =mrcal_point3_t mrcal_point3_scale(const mrcal_point3_t a, const double s)=
  - =mrcal_point3_t mrcal_point3_cross(const mrcal_point3_t a, const mrcal_point3_t b)=

  And similar for =mrcal_point2_t=, except there's no =mrcal_point2_cross()=

- Added simple point and pose printing utilities:
  - =mrcal_point2_print(p)=
  - =mrcal_point3_print(p)=
  - =mrcal_Rt_print(Rt)=
  - =mrcal_rt_print(rt)=

- =compose_r()=, =compose_rt()=, =compose_Rt()= have new arguments: =inverted0=
  and =inverted1=, to make it easier to use inverted transforms. The C macros
  =mrcal_compose_Rt()=, =mrcal_compose_rt()=, =mrcal_compose_r()= are unchanged,
  with new macros =...._inverted0()=, =...._inverted1()=, =...._inverted01()=.
  The corresponding =mrcal_compose_..._full()= functions have new arguments, and
  the API has a breaking change. The Python functions [[file:mrcal-python-api-reference.html#-compose_r][=mrcal.compose_r()=]] and
  [[file:mrcal-python-api-reference.html#-compose_rt][=mrcal.compose_rt()=]] and [[file:mrcal-python-api-reference.html#-compose_R][=mrcal.compose_R()=]] have new arguments, with default
  values, so this API remains compatible.

- =mrcal_image_uint8_load()= applies stretch equalization if given a 16-bit
  image. This is a reasonable default. If more specific processing is needed,
  call =mrcal_image_uint16_load()=

- The [[file:mrcal-cull-corners.html][=mrcal-cull-corners=]] tool has =--cull-rad-off-center-board= to throw out
  chessboard edges. Useful if we dont trust the chessboard shape

- Added [[file:mrcal-python-api-reference.html#cameramodel-optimization_inputs_reset][=mrcal.cameramodel.optimization_inputs_reset()=]] and
  [[file:mrcal-python-api-reference.html#cameramodel-valid_intrinsics_region_reset][=mrcal.cameramodel.valid_intrinsics_region_reset()=]] to unset these fields in a
  [[file:mrcal-python-api-reference.html#cameramodel][=mrcal.cameramodel=]].

- Added the [[https://www.github.com/dkogan/mrcal/blob/master/analyses/mrcal-convert-lensmodel-from-kalibr-fov][=analyses/mrcal-convert-lensmodel-from-kalibr-fov=]] tool to fit a
  Kalibr "fov" model into something that mrcal supports. This isn't
  general-enough or tested-enough to be fully distributed yet, so run it from
  the mrcal source tree if you need it

- The [[file:mrcal-python-api-reference.html#-compute_chessboard_corners][=mrcal.compute_chessboard_corners()=]] utility function has new
  =image_path_prefix= and =image_directory= kwargs to provide more options for
  interpreting paths in the given =corners_cache_vnl=. This is analogous to how
  other parts of mrcal work (for instance the
  [[file:mrcal-show-residuals-board-observation.html][=mrcal-show-residuals-board-observation=]] tool).

<2025-08-24 Sun> Added mrcal_cameramodel_converter is a "converter" function
that can be used with "O&" conversions in PyArg_ParseTupleAndKeywords() calls.
Can interpret either path strings or mrcal.cameramodel objects as
mrcal_cameramodel_t structures. This adds a dependency on
  - objcopy ("binutils" package)

<2025-08-24 Sun> added mrcal_image_void_t

<2025-09-20 Sat>
  - extrinsics_rt_fromref -> rt_cam_ref
  - extrinsics_Rt_fromref -> Rt_cam_ref
  - extrinsics_rt_toref   -> rt_ref_cam
  - extrinsics_Rt_toref   -> Rt_ref_cam
  
  - frames_rt_fromref     -> rt_frame_ref
  - frames_Rt_fromref     -> Rt_frame_ref
  - frames_rt_toref       -> rt_ref_frame
  - frames_Rt_toref       -> Rt_ref_frame
  
  This applies to the mrcal.cameramodel() constructor arguments and accessor
  functions. And to the mrcal.optimize() and mrcal.optimizer_callback() calls and
  to the contents of the optimization_inputs dict and the pywrap stuff.
  
  Compatibility logic is in place, so old code and data should just work

<2025-09-25 Thu>
  .cameramodel file extrinsics field is called "rt_cam_ref"
  Instead of "extrinsics". Old files can be read. Library writes both versions, so
  models written by new tools can still be read by old mrcal.


* Migration notes 2.4 -> 2.5

2024-12-06 compose_r(), compose_rt(), compose_Rt() have new args:
  inverted0,inverted1 BREAKING C ABI,API change: mrcal_compose_..._full() take
  the two new arguments. And mrcal_compose_rt_full() returns dt01/dr1 and
  dt01/dt0. The mrcal_compose_r(), mrcal_compose_rt() macros and the Python
  functions maintain the same interface

* todo
  #+end_example

- new observed_pixel_uncertainty
  - apply sqrt() factor. Documented in 68789474. git grep -n
    observed_pixel_uncertainty ..
  - Does too little data give smaller residuals? It should. Is this reflected in
    the sqrt() factor?

